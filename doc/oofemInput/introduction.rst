
Introduction
============

This manual describes in details the format and structure of OOFEM text
input file. Input file can be prepared in any text editor or can be
generated by a conversion program or FEM pre-processor.

.. _running-the-code:

Running the code
----------------

| The program can be executed by typing
| ``oofem [option [parameter]] ...``
| on the command line prompt with the following command line options:

=========== ================================================================================================================================================================================================================================================================================================================================================
-v          Prints oofem version.
-f path     Path to oofem input file name, if not present, program interactively reads this parameter.
-r int      Restarts the analysis from given solution step. The corresponding context file (\*.osf) must exist.
-rn         Turns on the equation renumbering. Default is off.
-ar int     Restarts the adaptive computation from given solution step. Requires the corresponding context file (\*.osf) and domain input file (\*.din) to exists. The domain input file describes the new mesh, its syntax is identical to syntax of input file, but it does not contains the output file record, job description record and analysis record.
-l int      Sets treshold for log messages (Errors=0, Warnings=1, Relevant=2, Info=3, Debug=4).
-qo path    Redirect the standard output stream (stdout) to given file.
-qe path    Redirect standard error stream (stderr) to given file.
-c          Forces the creation of context file for each solution step.
-t int      Determines the number of threads to use (requires OpenMP support compiled)
-p          Runs in parallel mode using MPI (requires MPI support compiled)
-m          Shows solution status monitor output, redirecting standard output to files (oofem.stdout, oofem.stderr by default, use `-qo` and `-qe` options to override)
=========== ================================================================================================================================================================================================================================================================================================================================================

| To execute OOFEM program in parallel MPI mode (indicated by the -p flag), users must know the procedure for executing/scheduling MPI jobs on the particular system(s). For instance, when using the MPICH implementation of MPI and many others, the following command initiates a program that uses eight processors:
| ``mpirun -np 8 oofem -p program_options``



Syntax and general rules
------------------------

Input file is composed of records. In the current implementation, each
record is represented by one line in input file. The order of records in
file is compulsory, and it has following structure:

#. output file record, see section :ref:`OutputFileRecord`,

#. job description record, see section :ref:`JobDescriptionRecord`,

#. analysis record, see section :ref:`AnalysisRecord`,

#. domain record, see section :ref:`DomainRecord`,

#. output manager record, see section :ref:`OutputManagerRecord`,

#. components size record, see section :ref:`ComponentsSizeRecord`,

#. node record(s), see section :ref:`NodeElementSideRecords`,

#. element record(s), see section :ref:`ElementsRecords`,

#. set record(s), see section :ref:`SetRecords`,

#. cross section record(s), see section :ref:`CrossSectionRecords`,

#. material type record(s), see section :ref:`MaterialTypeRecords`,

#. nonlocal barriers record(s), see section
   :ref:`NonlocalBarrierRecords`,

#. load, boundary conditions record(s), see section
   :ref:`LoadBoundaryInitialConditions`,

#. initial conditions record(s), see section
   :ref:`InitialConditions`,

#. time functions record(s), see section
   :ref:`TimeFunctionsRecords`.

#. optional xfem manager and associated record(s), see section
   :ref:`XFEMManagerRecords`

When input line begins with ’#’ character, then it is ignored by the
parser and can serve as a comment inside input file.

Long input records can be splitted into multiple input lines using 
continuation character '\\' at the end of each intermediate input line.
Also, from the input file one can include another file using @include directive.
The synatx is following:

::

   @include "mesh.in"

The individual records consist of record keyword followed by one or more
attributes. Each attribute is identified by its keyword, which can be
followed by attribute value(s). Some attributes have no values. The
order of attributes in the record is optional.

Sometimes, the record keyword itself can be variable, taking on a
restricted range of possible values. As an example, OOFEM has element
record, desribing particulat element, and record keyword determines the
particular element type. In this case, the record keyword is preceded by
star. We call such record keyword as entity keyword. The possible
substitutions for entity keyword are typed using ``Typewriter`` font
family. Often, some attributes are specific to particular entity
keyword. Then the general format of record is described and entity
specific attributes are described separately. The possible attributes
are then union of general and entity specific attributes.

::

   # nodal records
   Node 1 coords 3 0. 0. 0.
   Node 2 coords 3 0. 0. 2. dofidmask 3 1 2 3
   # element record
   Truss2d 1 nodes 2 1 2 crossSect 1

Each attribute value has a specific type, which describe its size and
layout. To describe the type of an attribute, the following notation is
used: ``Keyword #(type)``, where type determines the attribute type and
# is the placeholder for the attribute value. The possible types of
attribute values are following:

-  **in** - integer number.

   ::

      val1 25

-  **rn** - real number.

   ::

      val2 -0.234e-3

-  **ch** - character (usually for description of unknown type (’d’ for
   displacement, ’t’ for temperature, etc.).

   ::

      val3 t

-  **ia** - integer array. The format of integer array is
   ``size val(1) ... val(size)``, where size, val(1),...,val(size) are
   integer numbers. Values are separated by one or more spaces. As an
   example, consider the integer array attribute called
   ``nodes``\ :math:`=\{1,4,23\}`:

   ::

      nodes 3 1 4 23

-  **ra** - real array. The format of real array is
   ``size val(1) ... val(size)``, where size is integer number and val(1),
   ..., val(size) are real numbers. Values are separated by one or more
   spaces. As an example, consider the real array attribute called
   ``coords``\ :math:`=\{1.0,2.0,3.0\}`:

   ::

      coords 3 1.0 2.0 3.0

-  | **rm** - real matrix, format of real matrix is
   | ``rows columns {val(1,1) val(1,2) ...; val(2,1) ...}``, where “rows”
     and “columns” are integer numbers and val(1,1), ..., are real
     numbers. Columns are seperated by space or comma and lines by
     semicolon. As an example, consider the real matrix attribute called
     :math:`\texttt{mat1}=\left[\begin{array}{ccc}1.0&-1.0&0.0\\2.0&2.5&5.0\end{array}\right]`:

   ::

      mat1 2 3 \{1.0 -1.0; 0.0 2.0; 2.5 5.0\}

-  **dc** - dictionary. Dictionary consist of pairs, each pair has key
   (character type) and its associated value (integer type). Format of
   dictionary is ``size key(1) val(1) ... key(size) val(size)``, where
   size is integer number, key(1),...,key(size) are single character
   values, and val(1), ..., val(size) are real numbers. Values are
   separated by one or more spaces;

   ::

      dict1 2 a 1.0 v 0.0

-  **rl** - range list. Range list syntax is { number1 .. numberN
   (start1 end1) (start2 end2)}. The enclosing brackets are compulsory.
   The range list represent list of integer values. Single values can be
   specified using single values (number1, .., NumberN). The range of
   values (all numbers from startI to endI including startI and endI can
   be specified using range value in the form (startI endI). The range
   is described using its start and end values enclosed in parenthesis.
   Any number of ranges and single values can be used to specify range
   list.

   ::

      range1 { 1 7 8 (10 20) (25 30) }

-  **et** - entity type. For example, it describes the finite element
   type. Possible type values are mentioned in specific sections.

-  **s** - character string. The string have to be enclosed in quotes
   ("") following after corresponding keyword.

   ::

      string1 "string example"

-  **expr** - function expression. The expression have to be enclosed in
   quotes (""). The expression can be a value, simple expression (enclosed by $ characters) or reference to function record (starting with @ character followed by function record id). The simple expression is evaluated by internal parser and
   represent mathematical expressions as a function of certain
   variables. The variable names and meaning are described in specific
   sections. The usual arithmetic operators like -,+,*,/ are supported
   and their evaluation order is taken into account. The evaluation
   order can be changed using parenthesis. Several built-in functions
   are supported (sqrt, sin, cos, tan, atan, asin and acos) - these must
   be typed using lowercase letters and their arguments must be enclosed
   in parenthesis.

   ::

      expr1 "2.0"
      expr2 "$2.0*sin(t)/3.0$"
      expr3 "@2"

| The general format of record is
| [``attribute1_keyword #(type)``] ``...``
  [``attributeXX_keyword #(type)``] <``ver. 1.6``>

The keywords and their values are separated by one or more spaces.
Please note, that a single record corresponds to one input line in input
file.

When some attribute is enclosed in brackets [ ], then it’s use is
optional and often overwrites the default behavior or adds additional
(but optional) information or property (for example adds a loading to
node). The angle brackets < > are used to indicate the solver version requirements.

| Example of input record.
| As an example, consider the following record description:
| ``Particle`` ``color #(in)`` ``mass #(rn)`` ``coords #(ra)``
  ``name #(s)``
  The following listing shows the corresponding,
  properly formatted, input record:

::

   Particle 2 color 5 mass 0.18 coords 3 0.0 1.0 2.0 name "P1_36"

Output and Job description Records
==================================

.. _OutputFileRecord:

Output file record
------------------

This record has no keywords and contains a character string, which
describes the path to output file. If the file with the same name
exists, it will be overwritten.

.. _JobDescriptionRecord:

Job description record
----------------------

This record has no keywords and contains a character string, which
describes the job. This description will appear in the output file.

